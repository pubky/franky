'use client';

import { useState, useEffect, useMemo } from 'react';
import Image from 'next/image';

import * as Atoms from '@/atoms';
import * as Libs from '@/libs';
import * as Stores from '@/core';
import * as Molecules from '@/molecules';

interface DialogBackupPhraseProps {
  children?: React.ReactNode;
}

export function DialogBackupPhrase({ children }: DialogBackupPhraseProps) {
  const [isHidden, setIsHidden] = useState(true);
  const [recoveryWords, setRecoveryWords] = useState<string[]>([]);
  const [step, setStep] = useState(1);
  const { mnemonic } = Stores.useOnboardingStore();

  const handleClose = () => {
    setIsHidden(true);
    setStep(1);
  };

  useEffect(() => {
    if (mnemonic) {
      // Use existing mnemonic (generated by PublicKeyCard)
      setRecoveryWords(mnemonic.split(' '));
    }
  }, [mnemonic]);

  return (
    <Atoms.Dialog
      onOpenChange={(open) => {
        if (!open) {
          handleClose();
        }
      }}
    >
      {children ? (
        <Atoms.DialogTrigger asChild>{children}</Atoms.DialogTrigger>
      ) : (
        <Atoms.DialogTrigger asChild>
          <Atoms.Button id="backup-recovery-phrase-btn" className="gap-2">
            <span>Continue</span>
          </Atoms.Button>
        </Atoms.DialogTrigger>
      )}
      <Atoms.DialogContent className="gap-6 p-8" hiddenTitle="Backup recovery phrase">
        {step === 1 && (
          <RecoveryStep1
            recoveryWords={recoveryWords}
            isHidden={isHidden}
            setIsHidden={setIsHidden}
            setStep={setStep}
          />
        )}
        {step === 2 && <RecoveryStep2 recoveryWords={recoveryWords} setStep={setStep} />}
        {step === 3 && <RecoveryStep3 handleClose={handleClose} />}
      </Atoms.DialogContent>
    </Atoms.Dialog>
  );
}

function RecoveryStep1({
  recoveryWords,
  isHidden,
  setIsHidden,
  setStep,
}: {
  recoveryWords: string[];
  isHidden: boolean;
  setIsHidden: (isHidden: boolean) => void;
  setStep: (step: number) => void;
}) {
  return (
    <>
      <Atoms.DialogHeader className="space-y-1.5 pr-6">
        <Atoms.DialogTitle className="text-2xl font-bold leading-8 sm:text-xl sm:leading-7">
          Backup recovery phrase
        </Atoms.DialogTitle>
        <Atoms.DialogDescription className="text-sm leading-5 max-w-[530px]">
          Use the recovery phrase below to recover your account at a later date. Write down these 12 words in the
          correct order and store them in a safe place.{' '}
          <span className="text-brand font-bold">Never share this recovery phrase with anyone.</span>
        </Atoms.DialogDescription>
      </Atoms.DialogHeader>

      <Atoms.Container className={Libs.cn(isHidden && 'blur-xs')}>
        <Atoms.Container display="grid" className="grid-cols-2 md:grid-cols-3 gap-3">
          {recoveryWords.map((word, index) => (
            <Atoms.Container key={index} className="items-center gap-3 rounded-md bg-secondary p-4 flex-row">
              <Atoms.Badge
                id={`backup-recovery-phrase-word-${index + 1}`}
                variant="outline"
                className="h-5 min-w-[20px] rounded-full px-1 font-semibold"
              >
                {index + 1}
              </Atoms.Badge>
              <span className="text-base font-medium">{word}</span>
            </Atoms.Container>
          ))}
        </Atoms.Container>
      </Atoms.Container>

      <Atoms.Container className="gap-4 sm:gap-3 md:flex-row justify-between">
        {isHidden ? (
          <>
            <Atoms.DialogClose asChild>
              <Atoms.Button
                id="backup-recovery-phrase-cancel-btn"
                variant="outline"
                className="order-2 md:order-0 flex-1 rounded-full h-10 px-4 py-2.5 md:px-12 md:py-6"
              >
                Cancel
              </Atoms.Button>
            </Atoms.DialogClose>
            <Atoms.Button
              id="backup-recovery-phrase-reveal-btn"
              className="order-1 flex-1 rounded-full h-10 px-4 py-2.5 md:px-12 md:py-6"
              onClick={() => {
                setIsHidden(!isHidden);
                setStep(1);
              }}
            >
              <Libs.Eye className="mr-2 h-4 w-4" />
              Reveal recovery phrase
            </Atoms.Button>
          </>
        ) : (
          <>
            <Atoms.Button
              variant="outline"
              className="order-2 md:order-0 flex-1 rounded-full h-10 px-4 py-2.5 md:px-12 md:py-6"
              onClick={() => {
                setIsHidden(!isHidden);
                setStep(1);
              }}
            >
              <Libs.EyeOff className="mr-2 h-4 w-4" />
              Hide recovery phrase
            </Atoms.Button>
            <Atoms.Button
              id="backup-recovery-phrase-confirm-btn"
              className="order-1 flex-1 rounded-full h-10 px-4 py-2.5 md:px-12 md:py-6"
              onClick={() => setStep(2)}
            >
              <Libs.ArrowRight className="mr-2 h-4 w-4" />
              Confirm recovery phrase
            </Atoms.Button>
          </>
        )}
      </Atoms.Container>
    </>
  );
}

function RecoveryStep2({ recoveryWords, setStep }: { recoveryWords: string[]; setStep: (step: number) => void }) {
  const [userWords, setUserWords] = useState<string[]>(Array(12).fill(''));
  const [errors, setErrors] = useState<boolean[]>(Array(12).fill(false));
  const [availableWords] = useState<string[]>([...recoveryWords].sort());
  const [isLargeScreen, setIsLargeScreen] = useState(false);
  const [usedWordCounts, setUsedWordCounts] = useState<Record<string, number>>({});
  const [usedWordInstances, setUsedWordInstances] = useState<Set<number>>(new Set());
  const [slotToInstance, setSlotToInstance] = useState<(number | null)[]>(Array(12).fill(null));

  // Precompute word counts for better performance
  const wordCountMap = useMemo(() => {
    const map: Record<string, number> = {};
    for (const w of recoveryWords) {
      map[w] = (map[w] || 0) + 1;
    }
    return map;
  }, [recoveryWords]);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsLargeScreen(window.innerWidth >= 640);
    };

    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);

    return () => window.removeEventListener('resize', checkScreenSize);
  }, []);

  const validateSingleWord = (wordIndex: number, word: string) => {
    const newErrors = [...errors];
    // Check if this specific word is correct for its position
    const isError = word !== '' && word !== recoveryWords[wordIndex];
    newErrors[wordIndex] = isError;
    setErrors(newErrors);
  };

  const handleWordClick = (word: string, wordIndex: number) => {
    const wordCountInPhrase = wordCountMap[word] ?? 0;
    const currentUsageCount = usedWordCounts[word] || 0;

    if (currentUsageCount >= wordCountInPhrase) {
      return;
    }

    // Check if this specific word instance is already used
    if (usedWordInstances.has(wordIndex)) {
      return;
    }

    const emptyIndex = userWords.findIndex((w) => w === '');
    if (emptyIndex !== -1) {
      const newUserWords = [...userWords];
      newUserWords[emptyIndex] = word;
      setUserWords(newUserWords);

      setUsedWordCounts((prev) => ({
        ...prev,
        [word]: currentUsageCount + 1,
      }));
      setUsedWordInstances((prev) => new Set([...prev, wordIndex]));

      // Track slot to instance mapping
      setSlotToInstance((prev) => {
        const next = [...prev];
        next[emptyIndex] = wordIndex;
        return next;
      });

      // Validate this specific word immediately
      validateSingleWord(emptyIndex, word);
    }
  };

  const validateWords = () => {
    // Validate all words first
    const newErrors = userWords.map((word, index) => {
      return word !== '' && word !== recoveryWords[index];
    });
    setErrors(newErrors);

    // Check if all words are correct and filled
    const allFilled = userWords.every((word) => word !== '');
    const allCorrect = newErrors.every((error) => !error);

    // Only advance if all words are filled and correct
    if (allFilled && allCorrect) {
      setStep(3);
    }
  };

  const clearWord = (index: number) => {
    const word = userWords[index];
    if (word) {
      const newUserWords = [...userWords];
      newUserWords[index] = '';
      setUserWords(newUserWords);
      setUsedWordCounts((prev) => ({
        ...prev,
        [word]: Math.max(0, (prev[word] || 0) - 1),
      }));

      // Use the exact instance that was used in this slot
      const instanceIndex = slotToInstance[index];
      if (instanceIndex !== null) {
        setUsedWordInstances((prev) => {
          const next = new Set(prev);
          next.delete(instanceIndex);
          return next;
        });
        setSlotToInstance((prev) => {
          const next = [...prev];
          next[index] = null;
          return next;
        });
      }

      // Clear error for this specific word
      const newErrors = [...errors];
      newErrors[index] = false;
      setErrors(newErrors);
    }
  };

  return (
    <>
      <Atoms.DialogHeader className="space-y-1.5 pr-6">
        <Atoms.DialogTitle className="text-2xl sm:text-[24px] font-bold">Confirm recovery phrase</Atoms.DialogTitle>
        <Atoms.DialogDescription className="text-sm text-muted-foreground">
          Click or tap the 12 words in the correct order. Click on filled fields to remove words.
        </Atoms.DialogDescription>
      </Atoms.DialogHeader>

      <Atoms.Container className="space-y-6">
        <Atoms.Container className="flex-wrap gap-2 flex-row">
          {availableWords.map((word, index) => {
            const isThisInstanceUsed = usedWordInstances.has(index);

            return (
              <Atoms.Button
                id={`backup-recovery-phrase-word-${word}-${index + 1}`}
                key={`${word}-${index}`}
                variant={isThisInstanceUsed ? 'secondary' : 'outline'}
                size="sm"
                className={`rounded-full ${
                  isThisInstanceUsed
                    ? 'opacity-40 bg-transparent border text-muted-foreground cursor-not-allowed'
                    : 'border-transparent bg-secondary cursor-pointer'
                }`}
                onClick={() => !isThisInstanceUsed && handleWordClick(word, index)}
                disabled={isThisInstanceUsed}
              >
                {word}
              </Atoms.Button>
            );
          })}
        </Atoms.Container>

        <Atoms.Container display="grid" className="grid-cols-2 sm:grid-cols-3 gap-3">
          {userWords.map((word, i) => {
            const isCorrect = word !== '' && word === recoveryWords[i];
            const isError = errors[i];
            return (
              <Molecules.WordSlot
                key={i}
                mode="readonly"
                index={i}
                word={word}
                isCorrect={isCorrect}
                isError={isError}
                onClear={clearWord}
              />
            );
          })}
        </Atoms.Container>
      </Atoms.Container>

      <Atoms.Container className="flex-col-reverse sm:flex-row gap-3 sm:gap-4 sm:justify-end">
        <Atoms.Button
          variant="outline"
          className="rounded-full flex-1"
          size={isLargeScreen ? 'lg' : 'default'}
          onClick={() => setStep(1)}
        >
          <Libs.ArrowLeft className="mr-2 h-4 w-4" />
          Back
        </Atoms.Button>
        <Atoms.Button
          id="backup-recovery-phrase-validate-btn"
          className="rounded-full flex-1"
          size={isLargeScreen ? 'lg' : 'default'}
          onClick={validateWords}
          disabled={userWords.some((word) => word === '') || errors.some((error) => error)}
        >
          <Libs.Check className="mr-2 h-4 w-4" />
          Validate
        </Atoms.Button>
      </Atoms.Container>
    </>
  );
}

function RecoveryStep3({ handleClose }: { handleClose: () => void }) {
  return (
    <>
      <Atoms.DialogHeader className="pr-6 space-y-1.5">
        <Atoms.DialogTitle className="text-xl lg:text-2xl font-bold leading-7 lg:leading-8">
          Backup complete
        </Atoms.DialogTitle>
        <Atoms.DialogDescription className="text-sm font-medium text-muted-foreground leading-5">
          You can use your backed up recovery phrase to restore your account later.
        </Atoms.DialogDescription>
      </Atoms.DialogHeader>

      <Atoms.Container>
        <Atoms.Container className="w-full bg-card rounded-md p-6 flex items-center justify-center">
          <Image src="/images/check.png" alt="Backup Complete" width={180} height={180} className="w-48 h-48" />
        </Atoms.Container>
      </Atoms.Container>

      <Atoms.Container className="flex-col-reverse sm:flex-row gap-3 lg:gap-4 sm:justify-end">
        <Atoms.DialogClose asChild>
          <Atoms.Button variant="outline" className="rounded-full lg:h-[60px] lg:px-8 flex-1" onClick={handleClose}>
            Cancel
          </Atoms.Button>
        </Atoms.DialogClose>
        <Atoms.DialogClose asChild>
          <Atoms.Button
            id="backup-recovery-phrase-finish-btn"
            className="rounded-full lg:h-[60px] lg:px-8 flex-1"
            onClick={handleClose}
          >
            <Libs.ArrowRight className="mr-2 h-4 w-4" />
            Finish
          </Atoms.Button>
        </Atoms.DialogClose>
      </Atoms.Container>
    </>
  );
}
