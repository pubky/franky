import { describe, it, expect, vi, beforeEach } from 'vitest';
import * as Core from '@/core';
import type { TCreatePostParams, TReadPostsParams } from './post.types';

// Mock homeserver
const mockHomeserver = {
  fetch: vi.fn().mockResolvedValue({ ok: true }),
};

// Mock pubky-app-specs
vi.mock('pubky-app-specs', () => ({
  PubkySpecsBuilder: class {
    createPost(content: string, kind: string) {
      return {
        post: {
          content,
          kind,
          attachments: null,
          toJson: () => ({ content, kind }),
        },
        meta: {
          id: 'post123',
          url: `pubky://author/pub/pubky.app/posts/post123`,
        },
      };
    }
  },
  PubkyAppPostKind: {
    Short: 'Short',
    Long: 'Long',
  },
  postUriBuilder: (authorId: string, postId: string) => `pubky://${authorId}/pub/pubky.app/posts/${postId}`,
}));

// Test data
const testData = {
  authorPubky: 'pxnu33x7jtpx9ar1ytsi4yxbp6a5o36gwhffs8zoxmbuptici1jy' as Core.Pubky,
  postId: 'abc123xyz',
  get fullPostId() {
    return Core.buildPostCompositeId({ pubky: this.authorPubky, postId: this.postId });
  },
};

// Helper functions
const createPostParams = (content: string, parentPostId?: string): TCreatePostParams => ({
  content,
  authorId: testData.authorPubky,
  parentPostId,
});

const readPostsParams = (limit?: number, offset?: number): TReadPostsParams => ({
  limit,
  offset,
});

const setupExistingPost = async () => {
  const postDetails: Core.PostDetailsModelSchema = {
    id: testData.fullPostId,
    content: 'Test post content',
    indexed_at: Date.now(),
    kind: 'short',
    uri: `pubky://${testData.authorPubky}/pub/pubky.app/posts/${testData.postId}`,
    attachments: null,
  };

  await Core.PostDetailsModel.table.add(postDetails);
  await Core.PostCountsModel.table.add({
    id: testData.fullPostId,
    tags: 0,
    unique_tags: 0,
    replies: 0,
    reposts: 0,
  });
  await Core.PostRelationshipsModel.table.add({
    id: testData.fullPostId,
    replied: null,
    reposted: null,
    mentioned: [],
  });
};

describe('PostController', () => {
  beforeEach(async () => {
    vi.resetModules();
    vi.clearAllMocks();
    mockHomeserver.fetch.mockClear();

    // Mock Core module
    vi.doMock('@/core', async () => {
      const actual = await vi.importActual('@/core');
      return {
        ...actual,
        HomeserverService: {
          getInstance: vi.fn(() => mockHomeserver),
          request: vi.fn(async () => undefined),
        },
      };
    });

    // Initialize database and clear tables
    await Core.db.initialize();
    await Core.db.transaction(
      'rw',
      [
        Core.PostDetailsModel.table,
        Core.PostCountsModel.table,
        Core.PostRelationshipsModel.table,
        Core.PostTagsModel.table,
      ],
      async () => {
        await Core.PostDetailsModel.table.clear();
        await Core.PostCountsModel.table.clear();
        await Core.PostRelationshipsModel.table.clear();
        await Core.PostTagsModel.table.clear();
      },
    );
  });

  describe('read', () => {
    it('should be callable', async () => {
      const { PostController } = await import('./post');
      expect(PostController.read).toBeTypeOf('function');
    });

    it('should fetch posts with default pagination', async () => {
      await setupExistingPost();
      const { PostController } = await import('./post');

      const posts = await PostController.read();

      expect(posts).toBeInstanceOf(Array);
      expect(posts.length).toBeGreaterThanOrEqual(0);
    });

    it('should fetch posts with custom limit and offset', async () => {
      await setupExistingPost();
      const { PostController } = await import('./post');

      const posts = await PostController.read(readPostsParams(10, 5));

      expect(posts).toBeInstanceOf(Array);
    });

    it('should return empty array when no posts exist', async () => {
      const { PostController } = await import('./post');

      const posts = await PostController.read();

      expect(posts).toEqual([]);
    });
  });

  describe('create', () => {
    it('should be callable', async () => {
      const { PostController } = await import('./post');
      expect(PostController.create).toBeTypeOf('function');
    });

    it('should create a post and sync to homeserver', async () => {
      mockHomeserver.fetch.mockResolvedValueOnce({ ok: true });
      const { PostController } = await import('./post');

      await PostController.create(createPostParams('Hello, world!'));

      // Note: The actual post ID will be generated by the normalizer
      const allPosts = await Core.PostDetailsModel.table.toArray();
      expect(allPosts.length).toBeGreaterThan(0);

      const savedPost = allPosts[0];
      expect(savedPost.content).toBe('Hello, world!');
      expect(savedPost.kind).toBe('short');
    });

    it('should create a reply when parentPostId is provided', async () => {
      await setupExistingPost();
      mockHomeserver.fetch.mockResolvedValueOnce({ ok: true });
      const { PostController } = await import('./post');

      await PostController.create(createPostParams('This is a reply', testData.fullPostId));

      const allPosts = await Core.PostDetailsModel.table.toArray();
      const replyPost = allPosts.find((p) => p.content === 'This is a reply');

      expect(replyPost).toBeTruthy();
      expect(replyPost!.kind).toBe('short');
    });

    it('should trim whitespace from content', async () => {
      mockHomeserver.fetch.mockResolvedValueOnce({ ok: true });
      const { PostController } = await import('./post');

      await PostController.create(createPostParams('  Hello, world!  '));

      const allPosts = await Core.PostDetailsModel.table.toArray();
      const savedPost = allPosts[0];
      expect(savedPost.content).toBe('Hello, world!');
    });

    it('should throw error when parent post not found', async () => {
      const { PostController } = await import('./post');

      await expect(PostController.create(createPostParams('Reply', 'nonexistent:post'))).rejects.toThrow(
        'Failed to validate parent post',
      );
    });

    it('should normalize kind to lowercase before saving', async () => {
      mockHomeserver.fetch.mockResolvedValueOnce({ ok: true });
      const { PostController } = await import('./post');
      const ApplicationModule = await import('@/core/application');

      const createSpy = vi.spyOn(ApplicationModule.Post, 'create');

      await PostController.create(createPostParams('Hello, world!'));

      expect(createSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          kind: 'short',
        }),
      );
    });

    it('should map attachments null to undefined at application layer', async () => {
      mockHomeserver.fetch.mockResolvedValueOnce({ ok: true });
      const { PostController } = await import('./post');
      const ApplicationModule = await import('@/core/application');

      const createSpy = vi.spyOn(ApplicationModule.Post, 'create');

      await PostController.create(createPostParams('Hello, world!'));

      expect(createSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          attachments: undefined,
        }),
      );
    });
  });
});
